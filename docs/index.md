Всем привет.
Язык программирования Си предлагает возможность оперировать целочисленными значениями в четырех системах счисления.
Запишем число 10 в каждой из них.
Двоичная:
```C
int binary_number = 0b1010; // представление числа 10 в двоичной системе
```
Восьмеричная:
```C
int octal_number = 012; // представление числа 10 в восьмеричной системе
```
Десятичная:
```C
int number = 10; 
```
Шестнадцатеричная:
```C
int hex_number = 0xA; // представление числа 10 в шестнадцатеричной системе
```

Для указания соответствующей системы счисления используются префиксы (кроме десятичной).

И как оказалось, есть возможность использовать различные системы счисления в одном выражении. Что, надо сказать, однажды может привести к неожиданным результатам. Чему будет равна переменная а в привычной нам десятичной систему счисления:

```C
#include <stdlib.h>
#include <stdio.h>

int binary_number = 0b1010; //в двоичной системе

int octal_number = 012; //в восьмеричной системе

int number = 10;

int hex_number = 0xA; //в шестнадцатеричной системе


int main() {
    int a = 100 + 0100;

    printf("%d", a);
    return 0;
}
```

Почему 164? Дело в том что здесь складываются два числа:
100 в десятичной системе и 64 в восьмеричной (но записано как 0100).

Форматированный ввод и вывод описан в библиотеке stdio.h. И для каждой системы счисления используются свои спецификаторы. %d в текущем примере указывает на десятичное представление числа.


Выведем тоже число в остальных системах счисления:
```C
#include <stdlib.h>
#include <stdio.h>

int main() {
    int a = 100 + 0100;
    
    printf("number       - %d\n", a); //десятичное число
    printf("octal_number - %o\n", a); //восьмеричное число
    printf("hex_number   - %x\n", a); //шестнадцатеричное число (нижний регистр)
    printf("HEX_number   - %X\n", a); //шестнадцатеричное число (верхний регистр)
    return 0;
}
```
 Как вы вероятно заметили здесь нет бинарного числа, потому как в языке Си не предусмотрено его представление штатными средствами.

Для одного моего учебного проекта как раз потребовалось перевести число из десятичной в двоичную систему. И я нашел три способа это сделать.

В первом решении используется битовые операции: сдвиг вправо и битовое И.
Разберемся на примере.
Предположим число 19 требуется представить пользователю в бинарной системе. Хранить это представление будем в массиве заведомо достаточной длины. 
==PP==
Число 19 в оперативной памяти уже хранится в двоичной системе. Стоит задача извлечь каждый бит и занести в массив. Как функционирует данное выражение.
- На первом шаге итерации i = 0. Сдвиг вправо нулевой. В результате битового И получаем единицу. Записываем ее в нулевой элемент массива.
- На втором шаге i = 1. Сдвиг вправо на один бит. В результате битового И получаем также единицу. Записываем ее в первый элемент массива.
- На третьем шаге i = 2. Сдвиг вправо на два бита. В результате битового И получаем ноль. Записываем его во второй элемент массива.
- И в результате имеем массив битов, но как видно в инвертированном порядке. Поэтому для вывода на экран используем цикл for начиная с последнего элемента массива.

```C
#include <stdio.h>
#define LENGTH 8

int main() {
    int number = 19; //число в десятичной системе
    int binary_array[LENGTH] = {0};
    for (int i = 0; i < LENGTH; i++) {
        binary_array[i] = (number >> i) & 1;
    }

    printf("direct order  - ");
    for (int i = 0; i < LENGTH; i++) {
        printf("%d", binary_array[i]);
    }

    printf("\nreverse order - ");
    for (int i = LENGTH - 1; i >= 0; i--) {
        printf("%d", binary_array[i]);
    }

    return 0;
}
```


Второй способ классический перевод, который преподают на уроках информатики.
- Делим десятичное число на 2 и записываем остаток от деления.
- Результат деления вновь делим на 2 и опять записываем остаток.
- Повторяем операцию до тех пор пока результат деления не будет равен нулю.
- Запишем полученные остатки в обратном порядке, это и окажется искомое число.

Тот же массив заполняется битами, а преимущество данного метода в том, что благодаря счетчику заполнение происходит только значащими битами, нули в начале не включаются в массив.

```C
#include <stdio.h>

int main() {
    int number = 19; //число в десятичной системе
    int binary_array[20]; //массив битов
    int i = 0; //счетчик

    while(number){ //цикл пока num не равен 0
        binary_array[i] = number%2; // num%2 даст одну цифру двоичного числа
        number = number/2; //разделите число на 2, чтобы получить следующую цифру двоичного числа
        i++; //инкрементируем счетчик
    }

    while(i--) { //итерация по массиву в обратном порядке
        printf("%d", binary_array[i]);
    }
    return 0;
}
```

И третий вариант решения (стр174) функция itoa(), строенная в стандартную библиотеке stdlib
Она преобразует число типа int() в С-строку (другими словами - массив символов, последний элемент, которого содержит нулевой символ '/0' конца строки)

```C
#include <stdio.h>
#include <stdlib.h> //для _itoa

int main() {
    int number = 19; //число в десятичной системе
    int binary_array[20]; //массив битов

    //number - указываем число
    //binary_array - указатель на символьный массив, для записи результата
    //2 - система счисления (2, 8, 10, 16)
    _itoa(number, binary_array, 16);
    printf("%s\n", binary_array);

    _itoa(number, binary_array, 10);
    printf("%s\n", binary_array);

    _itoa(number, binary_array, 8);
    printf("%s\n", binary_array);

    _itoa(number, binary_array, 2);
    printf("%s\n", binary_array);

    return 0;
}
```

